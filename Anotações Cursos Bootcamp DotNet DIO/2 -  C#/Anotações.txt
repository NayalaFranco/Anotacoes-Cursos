escrever ctor e da tab tab = cria um construtor automaticamente
escreve prop e da tab tab = cria uma propriedade automaticamentes

----------------------

-Normalmente não é possivel utilizar palavras reservadas pelo C# como um nome de atributo, classe ou parametro, porem se colocar um @ na frente de uma palavra reservada vc consegue usa-la, mas não é ideal, então evite.

---------------------

OPERADOR TERNARIO= ?

------------------------

forma diferente de concatenar da que eu aprendi:
em vez de: ("Meu nome é " + nome + " e minha idade é " + idade + " anos");
da pra fazer: ($"Meu nome é {nome} e minha idade é {idade} anos");
q também funciona.

se fizer ($"alguma coisa {valorA >= valorB} alguma coisa")
ele vai aparecer um true ou false conforme o resultado da comparação desses valores, operadores aritmeticos tambem funcionam.

------------------------------

Da para ter varias copias da mesma classe em namespaces diferentes, o namespace é um caminho até a pasta q a classe está, ex: 
Using NomeDoProjeto.NomeDaPasta
ai quando for instanciar a classe, vc pode colocar o nome da classe q ele ja sabe q ta vindo dessa pasta, se tiver mais de um lugar com a mesma classe e vc tiver dando Using nesses lugares, ai precisa ter um certo cuidado na hora de instanciar a classe e detalhar mais.

----------------------------

Tipos de dados de variaveis:
https://www.tutorialspoint.com/csharp/csharp_data_types.htm

---------------
DateTime é um tipo de dado Struct que coleta a data e hora atual.

exemplo de uso:
DateTime dataAtual = DateTime.Now;
Console.WriteLine(dataAtual);
resultado vai ser o dia/mes/ano horario.

esse tipo tambem possui varios metodos, como por exemplo adicionar dias ao resultado:

DateTime dataAtual = DateTime.Now.AddDays(5); //adiciona 5 dias

e se fizer assim:
Console.WriteLine(dataAtual.ToString(dd/MM/yyyy));
ou
Console.WriteLine(dataAtual.ToShortDateString());
ele vai mostrar só a data sem o horario, e sim o M tem q ser maiúsculo.

e se fizer assim:
Console.WriteLine(dataAtual.ToString(HH:mm));
ou
Console.WriteLine(dataAtual.ToShortTimeString());
vai mostrar só a hora e o minuto sem os segundos, e o H tem q ser maiusculo.

DateTime.TryParseExact pode ser usado para converter uma data recebida em um padrão para outro, exemplo padrão americano para o padrão brasileiro.


Documentação do DateTime:
https://learn.microsoft.com/pt-br/dotnet/api/system.datetime?view=net-6.0

------------------
esses operadores atribuem e:
+= = adiciona
*= = multiplica
-= = subtrai

exemplo
C = C + 5;
é igual a
C += 5;
-------------------------

para converter tipos de variaveis existe o Convert e o Parse, exemp:
int a = Convert.ToInt32("5");
int a = int.Parse("5");
é preciso fazer tratamento de entrada pois se a entrada for algo q não é compativel vai dar erro e crashar o programa.

a diferença entre os 2 é q o Convert permite valor de entrada nulo e o parse nao. No caso do int o Convert vai converter null para 0.

se precisar converter algo para string, é só colocar .ToString(); depois da variavel. exemplo:
string texto = a.ToString();

nos tipos numericos, se vc passar um tipo compativel com outro tipo não é necessario converter.
exemplo um double que recebe o valor de um int, ou um long (q é um int q cabe mais numeros) recebendo um int.
MAS se um int for receber um long ele vai dar erro, se usar o convert ele aceita certinho SE o valor que tiver no long não for maior do q oq o int suporta, se for maior vai dar erro.


uma forma de converter sem dar erros é usando o TryParse, que espera ja q de erro então se ele nao conseguir ele só não faz o processo.
exemplo

string a = "15-";
int b = 0;

int.TryParse(a, out b);

aqui acontece o seguinte, como o valor de a é invalido pois tem um traço, ele vai dar erro, portanto ele não vai executar a operação e vai manter o valor de b como 0, se o valor de a não fosse invalido ele iria sobrescrever o valor de b com o valor convertido.

também é possivel gerar a variavel durante o TryParse:
int.TryParse(a, out int b);
ai se der erro, ele vai retornar 0 para b.

--------------------------

se digitar o comando:
long variavel = long.MaxValue;
variavel será carregado com o valor maximo q o long suporta.
os outros tipos tambem suportam esse .MaxValue; pode ser util para testes.

--------------------------------

o if não precisa ter comparador, se ele receber uma variavel booleana que seja true ou false ele ja determina o caminho, não precisa comparar a variavel boleana, exemp.: bool == true, apenas estar o bool que vai ta carregado com um true ou um false ja é o suficiente.

-------------------------------------

uso diferente do switch q eu não vi anteriormente na faculdade nem em cursos:

switch(letra)
{
	case "a":
	case "e":
	case "i":
	case "o":
	case "u":
		Console.WriteLine("Vogal");
		break;

	default:
		Console.WriteLine("Não é uma vogal");
		break;
}

logica: não é necessario ter um codigo em cada case, se ele não tiver o break ele vai continuar até chegar em um break, e se o resultado não bater com nenhum case ele vai pular todos e entrar no default como sempre.

-----------------------------------------

é possivel quebrar um laço de repetição antes do seu fim utilizando o comando: 
break; (igual do switch case)
a ideia é fazer um if com isso caso algo especifico seja alcançado antes do fim das repetições.

--------------------------------------------

Environment.Exit(0); encerra o programa.
Console.Clear(); limpa o console.

------------------------------------------------

FOREACH é usado principalmente com arrays, onde ele faz um for para cada elemento do array e joga o valor para dentro da variavel sem usar um contador de loop.

foreach(int valor in array)
{
	Console.WriteLine(valor);
}
em alguns casos pode ser uma desvantagem não ter um contador.
----------------------------------------------------

não é possivel alterar o tamanho de um array em tempo de execução, oque da para fazer é usar um codigo que vai pegar a referencia do array na memoria, copia-lo, apagar o array original e colocar no lugar na memoria um array novo com capacidade maior.
esse comando é
Array.Resize(ref nomeDoArray, 10);
nesse exemplo você está usando o comando ref para pegar a referencia na memoria do array, e dizendo que agora vc quer que ele tenha 10 espaços.
Também é possivel usar Array.Resize(ref nomeDoArray, nomeDoArray.Lenght * 2); por exemplo para dobrar o tamanho do array se assim for desejado.

----------------------------------------------------

para copiar um array para outro, usasse o comando:
Array.Copy(arrayOriginal, arrayDestino, arrayOriginal.Lenght);
no caso a ultima parte com o .Lenght é a quantidade de elementos que você quer copiar, se quer copiar tudo ou só os 2 primeiros por exemplo.

----------------------------------------------------

Listas são como arrays aprimorados, ela tem um array interno, você não precisa especificar seu tamanho (se quiser pode), você pode ir adicionando valores e ela vai crescendo sozinha (da resize no array interno sozinha), se remover um item ele reordena a lista e não deixa um espaço vago no meio como no array.
Declaração e uso:
List<string> listaString = new List<string>();
listaString.Add("nome");
listaString.Remove("nome");
quando precisar verificar o tamanho da lista, utiliza-se listaString.Count, funciona da mesma forma do array.Lenght

------------------------------------------------------
comentarios:
// = comenta uma unica linha
/* comentario */ = comenta multiplas linhas
<summary> = documenta classes e metodos, quando vc passa o mouse sobre ela la no outro arquivo que esta instanciada/usando aparece o comentario no balãozinho.
para usar o summary vc digita barra 3 vezes, no visual studio community ele ja auto completa o seguinte codigo:
/// <summary>
/// Texto que quer que apareça ao passar o mouse na classe/metodo.
/// </summary>
no VSCode para auto completar é necessario ativar
engrenagem > configurações > editor de texto > marcar a opção: Format On Type.
ou dentro de configurações usar a barra de busca digitanto format on type.

obs: o summary tem q estar logo acima da classe ou metodo que voce quer documentar.
obs2: se digitar as /// acima de uma classe com parametros, ele gera mais opções para voce documentar os parametros, a documentação desses parametros aparece no balão SOMENTE quando você está digitanto ela, ao colocar a virgula para ir para o proximo parametro ele muda a documentação para a do proximo parametro.
obs3: se a classe tiver return tambem tem um campo para documentar o retorno.
exemplo:
        /// <summary>
        /// Soma dois valores
        /// </summary>
        /// <param name="x">Primeiro valor a ser somado</param>
        /// <param name="y">Segundo valor a ser somado</param>
        /// <returns>Retorna a soma dos valores</returns>
        public int SomaPasseOMouseSummary(int x, int y)
        {
            //Console.WriteLine($"Resultado soma {x} + {y} = {x + y}");
            return x + y;
        }
-----------------------------------------------

quando o get ou o set tem apenas 1 linha de codigo de tratamento, pode se usar => (foi chamado de body expression na aula) ao inves de chaves.
exemplo:
get => _nome.ToUpper();

se você usar esse simbolo direto na propriedade, exemplo:
public string NomeCompleto => $"{Nome} {Sobrenome}";
automaticamente a propriedade vai ser somente GET e ela vai setar automaticamente o as variaveis concatenadas. Ou seja, se em Nome tiver Daniel e sobrenome tiver Franco, em nome completo vai ser armazenado Daniel Franco.

----------------------------------------------

public = qualquer um pode instanciar
private = somente a propria classe pode usar.

---------------------------------------------
se fizer isso aqui:
Pessoa p1 = new Pessoa(nome: "Daniel", sobrenome: "Franco");
funciona, no caso esses são os nomes dos parametros, fazer assim serve apenas para ficar mais legivel.
-------------------------------------------

precisa botar um M no valor do decimal, exemplo:
decimal valor = 10.12M;
assim como o float é f e o double é d.

-----------------------------------------------

se adicionar :C na exibição de um valor, ele adiciona o estilo monetario da região que o windows está configurado, no nosso caso R$ e ponto na casa do milhar, por exemplo:
decimal valorMonetario = 1522.55M;
Console.WriteLine(${valorMonetario:C}";
vai exibir:
R$ 1.522,55

se quiser forçar uma região da para fazer da seguinte forma:

using System.Globalization;

CultureInfo.DefaultThreadCurrentCulture = new CultureInfo("en-US");

como foi colocado en-US a localização foi para o americano, ai o codigo acima vai exibir o seguinte:
$ 1,522.55
que é o padrão de formatação de valor americano.

se quiser que apenas um valor seja no padrão americano por exemplo e o resto tudo no padrão brasileiro, da para fazer assim:

Console.WriteLine(valorMonetario.ToString("C", CultureInfo.CreateSpecificCulture("en-US")));

É possivel determinar o numero de casas apos a virgula colocando um numero apos o C, exemplo: C1, C2, C5, C8...

Se usar N no lugar do C, ele formata igual o C com a excessão do indicador monetario: R$, $...

Se utilizar P a formatação fica como porcentagem.
Porém, para o valor sair certo, tem que por ponto na frente do numero (porcentagem = .12; ), do contrario o numero 12 por exemplo vai ser mostrado como 1.200,00% ao invez de 12,00%
isso independente se for int, float, double ou decimal.

tambem é possivel fazer formatações manuais como por exemplo:
int numero = 123456;
Console.WriteLine(numero.ToString("##-##-##"));
a saida vai ser: 12-34-56
o # representa um digito.
-----------------------------------------------
verificar no projeto: TuplasTernarioEDesconstrucao
tuplas
ternario
desconstrutor
----------------------------------------------

para instalar um nuget no vscode vc vai no site nuget.org
escolhe um pacote nuget, clica, ai na pagina do pacote vai ter uma aba escrito ".NET CLI" e ai vai ter o comando de console certinho para copiar, colar e executar na pasta do projeto. E não precisa colocar a parte --version, para pegar sempre a ultima.

---------------------------------------------
verificar no projeto: SerializacaoEAtributos

Para fazer serialização em json no dotnet use o pacote nuget Newtonsoft.Json.

Para conferir se um json é valido, use este site:
https://codebeautify.org/jsonviewer

o json representa as horas recebidas pelo datetime de forma independente, usando o padrão ISO 8601.

A biblioteca json possui "Atributos" que são um codigo que fica acima das propriedades que permite alterar o comportamento de algumas coisas.
Exemplo:
[JsonProperty("Nome_Produto")]
public string Produto { get; set; }
esse atributo, ao receber no arquivo json uma propriedade com o nome "Nome_Produto" (que está fora da convenção de codigo do C# então você não vai querer fazer uma propriedade com o esse nome pois não está em PascalCase) ele vai dizer para o deserializador pegar essa propriedade e colocar na propriedade abaixo que é a Produto.

------------------------------------------------

Tipos Especiais, verificar no projeto: TiposEspeciais

tipos anulaveis:
bool? = variavel nullable, no caso do bool aceita receber null ao inves de apenas true e false, e altera seu funcionamento, onde antes em um if era só colocar o nome da variavel que ja pegava se era true ou false, e agora é nessessario colocar nomeDaVariavel.Value para simplesmente pegar se é true ou false. E é bom conferir com .HasValue para ver se não é null para evitar erros.

tipos anonimos

tipo dinâmico

classes genericas

metodos de extensão


---------------------------------------------------

(Teorico, bom saber para entrevista de emprego)

- Alocação de Memória 

Stack e Heap são tipos de memoria, dependendo do tipo da sua variavel ela vai para um ou outro tipo de memoria.

o Stack é como uma pilha, ele armazena conforme a sequencia que a variavel entrou (primeira linha, segunda linha...), o ultimo a entrar é o primeiro a sair (LIFO - Last In, First Out).

No Stack são armazanados tipos de variaveis mais simples (tipos primitivos), e quando a variavel é complexa como um objeto ele armazena o nome do objeto e a referencia desse objeto que vai estar na memoria Heap.

Na memoria Heap são armazenados tipos complexos como objetos, já que objetos podem conter varios tipos diferentes dentro dele.

Portanto ao armazenar um objeto, seu nome ficará na Stack e haverá uma referencia para o objeto de verdade que está na memoria Heap.

- Limpeza de memória

Ao terminar o metodo, a limpeza de memoria ocorrerá da seguinte forma:
Na memória Stack é tipo uma pilha, ela vai remover da memoria a partir da ultima variavel que entrou na Stack.

Na memória Heap o C# usa o Garbage Collector, que verifica se tem algum objeto que não tem mais referencia na memoria Stack, pois se não houver referencia não tem como ele ser usado, então todo objeto da memória Heap que não tem mais ligação nenhuma com a memória Stack o Garbage Collector apaga da memoria. Por isso ela não tem uma ordem de limpeza como a Stack, pois um objeto ainda pode estar sendo usado enquanto o proximo e o anterior que entraram ja foram eliminados porque não tiveram mais uso.

- Tipos de valor
O tipo de valor armazena dados estáticos e não complexos.
São tipos simples, como int, float, string, decimal, eles conseguem armazenar seus nomes e seus dados dentro da Stack pois são simples.
E se por exemplo:
int a = 5;
int b = a;
Ele vai salvar na memória stack da seguinte forma:
a = 5;
b = 5;
Ele não vai criar uma referencia ao a, e sim vai copiar o valor para b.
Portanto se vc alterar o valor de b, somente b será alterado.

- Tipos de referência
O tipo de referência armazena dados dinâmicos e complexos.
São tipos mais complexos, pois podem possuir varios tipos simples e até outros tipos complexos, dentro deles, então na memoria Stack é armazenado só o nome e a REFERÊNCIA do verdadeiro tipo que está armazenado lá na memoria heap.
E se por exemplo:
Pessoa p1 = new Pessoa("Daniel", "Franco");
Pessoa p2 = p1;
ele vai salvar na memoria p1 e p2 apontando para o mesmo objeto, portanto se você fizer:
p2.Nome = "Luis";
tanto p1 quanto p2 irão mudar seus dados para "Luis" "Franco", pois ao criar um novo objeto sem instanciar você apenas está criando um novo nome apontando para o mesmo lugar na memoria Heap.
Então você NÃO cria uma copia de um "tipo complexo" dessa forma como nos "tipos simples".
E se ambos apontam para o mesmo lugar, quando altera um altera o outro TAMBÉM.
Ou seja para criar um p2 tem que colocar new Pessoa, ai ele vai instanciar um novo objeto na memoria Heap, e para copiar os dados de p1 para p2 tem que ser feito de forma manual mesmo. Nem se instanciar ambos e depois fizer p2 = p1, isso vai fazer o p2 apontar para o p1 e quando vc for editar o p2 ele vai alterar o p1 do mesmo jeito.



