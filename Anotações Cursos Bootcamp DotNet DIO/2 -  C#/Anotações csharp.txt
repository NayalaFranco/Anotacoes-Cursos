escrever ctor e da tab tab = cria um construtor automaticamente
escreve prop e da tab tab = cria uma propriedade automaticamentes

----------------------

-Normalmente não é possivel utilizar palavras reservadas pelo C# como um nome de atributo, classe ou parametro, porem se colocar um @ na frente de uma palavra reservada vc consegue usa-la, mas não é ideal, então evite.

---------------------

OPERADOR TERNARIO= ?

------------------------

forma diferente de concatenar da que eu aprendi:
em vez de: ("Meu nome é " + nome + " e minha idade é " + idade + " anos");
da pra fazer: ($"Meu nome é {nome} e minha idade é {idade} anos");
q também funciona.

se fizer ($"alguma coisa {valorA >= valorB} alguma coisa")
ele vai aparecer um true ou false conforme o resultado da comparação desses valores, operadores aritmeticos tambem funcionam.

------------------------------

----------------------------

Tipos de dados de variaveis:
https://www.tutorialspoint.com/csharp/csharp_data_types.htm

---------------


------------------
esses operadores atribuem e:
+= = adiciona
*= = multiplica
-= = subtrai

exemplo
C = C + 5;
é igual a
C += 5;
-------------------------

para converter tipos de variaveis existe o Convert e o Parse, exemp:
int a = Convert.ToInt32("5");
int a = int.Parse("5");
é preciso fazer tratamento de entrada pois se a entrada for algo q não é compativel vai dar erro e crashar o programa.

a diferença entre os 2 é q o Convert permite valor de entrada nulo e o parse nao. No caso do int o Convert vai converter null para 0.

se precisar converter algo para string, é só colocar .ToString(); depois da variavel. exemplo:
string texto = a.ToString();

nos tipos numericos, se vc passar um tipo compativel com outro tipo não é necessario converter.
exemplo um double que recebe o valor de um int, ou um long (q é um int q cabe mais numeros) recebendo um int.
MAS se um int for receber um long ele vai dar erro, se usar o convert ele aceita certinho SE o valor que tiver no long não for maior do q oq o int suporta, se for maior vai dar erro.


uma forma de converter sem dar erros é usando o TryParse, que espera ja q de erro então se ele nao conseguir ele só não faz o processo.
exemplo

string a = "15-";
int b = 0;

int.TryParse(a, out b);

aqui acontece o seguinte, como o valor de a é invalido pois tem um traço, ele vai dar erro, portanto ele não vai executar a operação e vai manter o valor de b como 0, se o valor de a não fosse invalido ele iria sobrescrever o valor de b com o valor convertido.

também é possivel gerar a variavel durante o TryParse:
int.TryParse(a, out int b);
ai se der erro, ele vai retornar 0 para b.

--------------------------

se digitar o comando:
long variavel = long.MaxValue;
variavel será carregado com o valor maximo q o long suporta.
os outros tipos tambem suportam esse .MaxValue; pode ser util para testes.

--------------------------------

o if não precisa ter comparador, se ele receber uma variavel booleana que seja true ou false ele ja determina o caminho, não precisa comparar a variavel boleana, exemp.: bool == true, apenas estar o bool que vai ta carregado com um true ou um false ja é o suficiente.

-------------------------------------

uso diferente do switch q eu não vi anteriormente na faculdade nem em cursos:

switch(letra)
{
	case "a":
	case "e":
	case "i":
	case "o":
	case "u":
		Console.WriteLine("Vogal");
		break;

	default:
		Console.WriteLine("Não é uma vogal");
		break;
}

logica: não é necessario ter um codigo em cada case, se ele não tiver o break ele vai continuar até chegar em um break, e se o resultado não bater com nenhum case ele vai pular todos e entrar no default como sempre.

-----------------------------------------

é possivel quebrar um laço de repetição antes do seu fim utilizando o comando: 
break; (igual do switch case)
a ideia é fazer um if com isso caso algo especifico seja alcançado antes do fim das repetições.

--------------------------------------------

Environment.Exit(0); encerra o programa.
Console.Clear(); limpa o console.

------------------------------------------------

FOREACH é usado principalmente com arrays, onde ele faz um for para cada elemento do array e joga o valor para dentro da variavel sem usar um contador de loop.

foreach(int valor in array)
{
	Console.WriteLine(valor);
}
em alguns casos pode ser uma desvantagem não ter um contador.
----------------------------------------------------

não é possivel alterar o tamanho de um array em tempo de execução, oque da para fazer é usar um codigo que vai pegar a referencia do array na memoria, copia-lo, apagar o array original e colocar no lugar na memoria um array novo com capacidade maior.
esse comando é
Array.Resize(ref nomeDoArray, 10);
nesse exemplo você está usando o comando ref para pegar a referencia na memoria do array, e dizendo que agora vc quer que ele tenha 10 espaços.
Também é possivel usar Array.Resize(ref nomeDoArray, nomeDoArray.Lenght * 2); por exemplo para dobrar o tamanho do array se assim for desejado.

----------------------------------------------------

para copiar um array para outro, usasse o comando:
Array.Copy(arrayOriginal, arrayDestino, arrayOriginal.Lenght);
no caso a ultima parte com o .Lenght é a quantidade de elementos que você quer copiar, se quer copiar tudo ou só os 2 primeiros por exemplo.

----------------------------------------------------

Listas são como arrays aprimorados, ela tem um array interno, você não precisa especificar seu tamanho (se quiser pode), você pode ir adicionando valores e ela vai crescendo sozinha (da resize no array interno sozinha), se remover um item ele reordena a lista e não deixa um espaço vago no meio como no array.
Declaração e uso:
List<string> listaString = new List<string>();
listaString.Add("nome");
listaString.Remove("nome");
quando precisar verificar o tamanho da lista, utiliza-se listaString.Count, funciona da mesma forma do array.Lenght

------------------------------------------------------
comentarios:
// = comenta uma unica linha
/* comentario */ = comenta multiplas linhas
<summary> = documenta classes e metodos, quando vc passa o mouse sobre ela la no outro arquivo que esta instanciada/usando aparece o comentario no balãozinho.
para usar o summary vc digita barra 3 vezes, no visual studio community ele ja auto completa o seguinte codigo:
/// <summary>
/// Texto que quer que apareça ao passar o mouse na classe/metodo.
/// </summary>
no VSCode para auto completar é necessario ativar
engrenagem > configurações > editor de texto > marcar a opção: Format On Type.
ou dentro de configurações usar a barra de busca digitanto format on type.

obs: o summary tem q estar logo acima da classe ou metodo que voce quer documentar.
obs2: se digitar as /// acima de uma classe com parametros, ele gera mais opções para voce documentar os parametros, a documentação desses parametros aparece no balão SOMENTE quando você está digitanto ela, ao colocar a virgula para ir para o proximo parametro ele muda a documentação para a do proximo parametro.
obs3: se a classe tiver return tambem tem um campo para documentar o retorno.
exemplo:
        /// <summary>
        /// Soma dois valores
        /// </summary>
        /// <param name="x">Primeiro valor a ser somado</param>
        /// <param name="y">Segundo valor a ser somado</param>
        /// <returns>Retorna a soma dos valores</returns>
        public int SomaPasseOMouseSummary(int x, int y)
        {
            //Console.WriteLine($"Resultado soma {x} + {y} = {x + y}");
            return x + y;
        }
-----------------------------------------------

quando o get ou o set tem apenas 1 linha de codigo de tratamento, pode se usar => (foi chamado de body expression na aula) ao inves de chaves.
exemplo:
get => _nome.ToUpper();

se você usar esse simbolo direto na propriedade, exemplo:
public string NomeCompleto => $"{Nome} {Sobrenome}";
automaticamente a propriedade vai ser somente GET e ela vai setar automaticamente o as variaveis concatenadas. Ou seja, se em Nome tiver Daniel e sobrenome tiver Franco, em nome completo vai ser armazenado Daniel Franco.

----------------------------------------------

public = qualquer um pode instanciar
private = somente a propria classe pode usar.

---------------------------------------------
se fizer isso aqui:
Pessoa p1 = new Pessoa(nome: "Daniel", sobrenome: "Franco");
funciona, no caso esses são os nomes dos parametros, fazer assim serve apenas para ficar mais legivel.
-------------------------------------------

precisa botar um M no valor do decimal, exemplo:
decimal valor = 10.12M;
assim como o float é f e o double é d.

-----------------------------------------------

se adicionar :C na exibição de um valor, ele adiciona o estilo monetario da região que o windows está configurado, no nosso caso R$ e ponto na casa do milhar, por exemplo:
decimal valorMonetario = 1522.55M;
Console.WriteLine(${valorMonetario:C}";
vai exibir:
R$ 1.522,55

se quiser forçar uma região da para fazer da seguinte forma:

using System.Globalization;

CultureInfo.DefaultThreadCurrentCulture = new CultureInfo("en-US");

como foi colocado en-US a localização foi para o americano, ai o codigo acima vai exibir o seguinte:
$ 1,522.55
que é o padrão de formatação de valor americano.

se quiser que apenas um valor seja no padrão americano por exemplo e o resto tudo no padrão brasileiro, da para fazer assim:

Console.WriteLine(valorMonetario.ToString("C", CultureInfo.CreateSpecificCulture("en-US")));

É possivel determinar o numero de casas apos a virgula colocando um numero apos o C, exemplo: C1, C2, C5, C8...

Se usar N no lugar do C, ele formata igual o C com a excessão do indicador monetario: R$, $...

Se utilizar P a formatação fica como porcentagem.
Porém, para o valor sair certo, tem que por ponto na frente do numero (porcentagem = .12; ), do contrario o numero 12 por exemplo vai ser mostrado como 1.200,00% ao invez de 12,00%
isso independente se for int, float, double ou decimal.

tambem é possivel fazer formatações manuais como por exemplo:
int numero = 123456;
Console.WriteLine(numero.ToString("##-##-##"));
a saida vai ser: 12-34-56
o # representa um digito.
-----------------------------------------------
verificar no projeto: TuplasTernarioEDesconstrucao
tuplas
ternario
desconstrutor
----------------------------------------------



---------------------------------------------
verificar no projeto: SerializacaoEAtributos

Para fazer serialização em json no dotnet use o pacote nuget Newtonsoft.Json.

Para conferir se um json é valido, use este site:
https://codebeautify.org/jsonviewer

o json representa as horas recebidas pelo datetime de forma independente, usando o padrão ISO 8601.

A biblioteca json possui "Atributos" que são um codigo que fica acima das propriedades que permite alterar o comportamento de algumas coisas.
Exemplo:
[JsonProperty("Nome_Produto")]
public string Produto { get; set; }
esse atributo, ao receber no arquivo json uma propriedade com o nome "Nome_Produto" (que está fora da convenção de codigo do C# então você não vai querer fazer uma propriedade com o esse nome pois não está em PascalCase) ele vai dizer para o deserializador pegar essa propriedade e colocar na propriedade abaixo que é a Produto.

------------------------------------------------

Tipos Especiais, verificar no projeto: TiposEspeciais

tipos anulaveis:
bool? = variavel nullable, no caso do bool aceita receber null ao inves de apenas true e false, e altera seu funcionamento, onde antes em um if era só colocar o nome da variavel que ja pegava se era true ou false, e agora é nessessario colocar nomeDaVariavel.Value para simplesmente pegar se é true ou false. E é bom conferir com .HasValue para ver se não é null para evitar erros.

tipos anonimos

tipo dinâmico

classes genericas

metodos de extensão


---------------------------------------------------



--------------------------------------------------


